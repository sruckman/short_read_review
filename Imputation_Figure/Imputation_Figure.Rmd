---
title: "Imputation"
author: "Sarah Ruckman"
date: "`r Sys.Date()`"
output:
  html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{python imputation, eval=FALSE}
#!/usr/bin/env python3
import msprime as msp
import tskit
import numpy as np
import random

rng = np.random.default_rng(20251010)

# Human-like Parameters for a 200kb region
# I bet I could go small, like 100kb, maybe even 50kb
# this would give stronger haplotypes
n_hap = 20 # number of haplotypes (rows)
L = 200000 # 200 kb
Ne = 10000
mu = 1e-8
recomb = 1e-8

# Simulate tree sequence with mutations
# IMPORTANT: simulate haploid samples by setting ploidy=1
# This yields exactly n_hap genotypes per variant

ts = msp.sim_ancestry(
    samples=n_hap, ploidy=1, recombination_rate=recomb, sequence_length=L,
    population_size=Ne, random_seed=20251010
)
ts = msp.sim_mutations(ts, rate=mu, random_seed=20251011)

# Collect biallelic 0/1 variants only
variants = []
for var in ts.variants():
    if len(var.alleles) >= 2:
        g = var.genotypes.astype(np.int8)
        unique = np.unique(g)
        if set(unique.tolist()).issubset({0, 1}):
            variants.append(g)

if len(variants) < 20:
    raise SystemExit(f"Only {len(variants)} segregating biallelic SNPs; increase parameters and rerun.")

G = np.vstack(variants) # shape: num_sites x n_hap
# Sanity: enforce expected width
if G.shape[1] != n_hap:
    raise SystemExit(f"Unexpected number of genotypes per site: {G.shape[1]} (expected {n_hap}).")

# Compute MAF per site
allele_counts = G.sum(axis=1)
maf = np.minimum(allele_counts, n_hap - allele_counts) / n_hap

# Select top-20 MAF SNPs
idx = np.argsort(maf)[::-1][:20]
G20 = G[idx, :].T # shape: n_hap x 20 (rows=hyp, cols=sites)
maf20 = maf[idx]

# Map 0/1 to allele letters per SNP using allowed pairs
snp_pairs_list = [
    ("A", "T"), ("A", "C"), ("A", "G"), ("C", "G"), ("C", "T"), ("G", "T")
]
assignments = rng.integers(0, len(snp_pairs_list), size=G20.shape[1])
allele_pairs = [snp_pairs_list[k] for k in assignments]

# Build Case 0 matrix of letters
case0 = np.empty_like(G20, dtype='<U1')
for j in range(G20.shape[1]):
    a0, a1 = allele_pairs[j]
    case0[:, j] = np.where(G20[:, j] == 0, a0, a1)

# Case 1: lower panel rows 10..19 keep 6 columns, others '?'
case1 = case0.copy()
keep_cols = rng.choice(G20.shape[1], size=6, replace=False)
for i in range(10, 20):
    for j in range(G20.shape[1]):
        if j not in keep_cols:
            case1[i, j] = '?'

# Case 2: lower panel 80% missing at random (per cell)
case2 = case0.copy()
for i in range(10, 20):
    missing = rng.choice(G20.shape[1], size=int(np.ceil(0.8 * G20.shape[1])), replace=False)
    case2[i, missing] = '?'

# Case 3: all rows 80% missing at random (per cell)
case3 = case0.copy()
for i in range(0, 20):
    missing = rng.choice(G20.shape[1], size=int(np.ceil(0.8 * G20.shape[1])), replace=False)
    case3[i, missing] = '?'


def format_panel(mat: np.ndarray) -> list[str]:
    lines = []
    for i in range(mat.shape[0]):
        row = ''.join(mat[i, :])
        if i == 9:
            lines.append(row + "\n")
        else:
            lines.append(row)
    return lines

out = []
out.append("IMPUTATION METHODS FIGURE (msprime-based)")
out.append("==========================================")
out.append("")

out.append("CASE 0: Complete Genotype Data (Top-20 MAF SNPs)")
out.append("===============================================")
out.extend(format_panel(case0))
out.append("")

out.append("CASE 1: Reference Panel + SNP Chip (6 columns known in lower panel)")
out.append("==================================================================")
out.extend(format_panel(case1))
out.append("")

out.append("CASE 2: Reference Panel + Low Coverage Sequencing (0.2X)")
out.append("========================================================")
out.extend(format_panel(case2))
out.append("")

out.append("CASE 3: All Individuals with 80% Missing Data (no reference)")
out.append("==========================================================")
out.extend(format_panel(case3))

with open('formatted.txt', 'w') as f:
    f.write('\n'.join(out) + '\n')

# Print a brief summary to stdout
for j, (a0, a1) in enumerate(allele_pairs, start=1):
    print(f"Col {j:02d}: {a0} vs {a1} (MAF={maf20[j-1]:.2f})")


```

```{r run_script, eval=FALSE}
#Run the python script
reticulate::source_python("imputation_script.py")
```

```{python, eval=FALSE}
# Define the two matrices
matrix1 = [
    ['?', '?', 'A', 'C', '?', 'T', '?', 'T', '?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', 'C', '?'],
    ['?', '?', 'A', 'A', '?', 'G', '?', 'C', '?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', 'G', '?'],
    ['?', '?', 'G', 'A', '?', 'G', '?', 'G', '?', '?', '?', '?', '?', 'A', '?', '?', '?', '?', 'G', '?'],
    ['?', '?', 'G', 'A', '?', 'T', '?', 'T', '?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', 'G', '?'],
    ['?', '?', 'A', 'A', '?', 'T', '?', 'C', '?', '?', '?', '?', '?', 'A', '?', '?', '?', '?', 'C', '?'],
    ['?', '?', 'G', 'C', '?', 'T', '?', 'T', '?', '?', '?', '?', '?', 'A', '?', '?', '?', '?', 'G', '?'],
    ['?', '?', 'A', 'A', '?', 'G', '?', 'C', '?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', 'C', '?'],
    ['?', '?', 'G', 'C', '?', 'G', '?', 'T', '?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', 'C', '?'],
    ['?', '?', 'A', 'C', '?', 'T', '?', 'T', '?', '?', '?', '?', '?', 'A', '?', '?', '?', '?', 'C', '?'],
    ['?', '?', 'G', 'A', '?', 'G', '?', 'T', '?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', 'C', '?'],
    ['?', '?', 'A', 'C', '?', 'T', '?', 'T', '?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', 'C', '?'],
    ['?', '?', 'A', 'A', '?', 'G', '?', 'C', '?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', 'G', '?'],
    ['?', '?', 'G', 'A', '?', 'G', '?', 'G', '?', '?', '?', '?', '?', 'A', '?', '?', '?', '?', 'G', '?'],
    ['?', '?', 'G', 'A', '?', 'T', '?', 'T', '?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', 'G', '?'],
    ['?', '?', 'A', 'A', '?', 'T', '?', 'C', '?', '?', '?', '?', '?', 'A', '?', '?', '?', '?', 'C', '?'],
    ['?', '?', 'G', 'C', '?', 'T', '?', 'T', '?', '?', '?', '?', '?', 'A', '?', '?', '?', '?', 'G', '?'],
    ['?', '?', 'A', 'A', '?', 'G', '?', 'C', '?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', 'C', '?'],
    ['?', '?', 'G', 'C', '?', 'G', '?', 'T', '?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', 'C', '?'],
    ['?', '?', 'A', 'C', '?', 'T', '?', 'T', '?', '?', '?', '?', '?', 'A', '?', '?', '?', '?', 'C', '?'],
    ['?', '?', 'G', 'A', '?', 'G', '?', 'T', '?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', 'C', '?']
]

matrix2 = [
    ['G', 'T', '?', '?', '?', '?', '?', '?', '?', '?', '?', 'T', 'C', '?', '?', '?', '?', '?', '?', '?'],
    ['?', 'T', '?', '?', '?', '?', '?', '?', '?', '?', 'T', 'A', '?', '?', '?', 'A', '?', '?', '?', '?'],
    ['?', '?', '?', '?', '?', '?', 'A', '?', '?', '?', '?', 'A', 'A', '?', '?', '?', '?', 'A', '?', '?'],
    ['?', 'T', '?', '?', '?', '?', '?', '?', '?', '?', '?', 'A', '?', '?', '?', 'G', 'A', '?', '?', '?'],
    ['?', '?', '?', '?', '?', '?', '?', 'C', 'C', '?', '?', '?', '?', '?', '?', '?', 'A', '?', 'C', '?'],
    ['?', '?', '?', '?', 'C', '?', '?', 'T', 'G', '?', '?', '?', '?', '?', '?', '?', 'A', '?', '?', '?'],
    ['?', '?', '?', '?', '?', '?', '?', '?', '?', '?', '?', '?', 'C', 'G', '?', '?', '?', 'T', '?', 'T'],
    ['?', '?', '?', '?', '?', 'G', '?', '?', '?', '?', '?', '?', 'C', '?', 'C', '?', 'G', '?', '?', '?'],
    ['?', '?', '?', '?', '?', '?', '?', '?', 'C', '?', '?', '?', '?', '?', '?', '?', 'G', 'A', 'C', '?'],
    ['?', '?', 'G', '?', 'C', '?', '?', '?', '?', '?', '?', '?', '?', 'G', 'T', '?', '?', '?', '?', '?'],
    ['G', '?', '?', '?', '?', '?', '?', '?', '?', '?', '?', 'T', '?', 'C', '?', '?', '?', '?', '?', '?'],
    ['?', 'T', '?', '?', '?', '?', '?', '?', 'T', '?', 'A', '?', '?', 'A', '?', '?', '?', '?', '?', '?'],
    ['?', '?', '?', '?', '?', 'A', '?', '?', '?', '?', '?', 'A', '?', 'A', '?', '?', '?', 'A', '?', '?'],
    ['?', 'T', '?', '?', '?', '?', '?', 'C', '?', '?', 'A', '?', '?', 'G', '?', 'A', '?', '?', '?', '?'],
    ['?', '?', '?', '?', '?', '?', 'C', '?', 'C', '?', '?', '?', '?', '?', '?', 'A', '?', '?', 'C', '?'],
    ['?', '?', '?', 'C', '?', '?', '?', 'T', '?', 'G', '?', '?', '?', '?', '?', '?', 'A', '?', '?', '?'],
    ['?', '?', '?', '?', '?', '?', '?', '?', '?', '?', '?', 'C', '?', '?', 'G', '?', '?', 'T', '?', 'T'],
    ['?', '?', '?', '?', 'G', '?', '?', '?', '?', '?', 'C', '?', '?', 'C', '?', '?', '?', 'G', '?', '?'],
    ['?', '?', '?', '?', '?', '?', '?', 'C', '?', '?', '?', '?', '?', '?', 'G', '?', '?', 'A', 'C', '?'],
    ['?', '?', 'G', '?', 'C', '?', '?', '?', '?', '?', '?', '?', '?', 'G', '?', 'T', '?', '?', '?', '?']
]

# Initialize the matrix to store the results
result_matrix = []

# Loop through each row of the matrices
for i in range(len(matrix1)):
    row1 = matrix1[i]
    row2 = matrix2[i]
    result_row = []

    # Loop through each element in the row
    for j in range(len(row1)):
        char1 = row1[j]
        char2 = row2[j]

        # If characters are the same, keep it
        if char1 == char2:
            result_row.append(char1)
        # If one character is '?', use the other character
        elif char1 == '?':
            result_row.append(char2)
        elif char2 == '?':
            result_row.append(char1)
        # If they are different letters, it's a conflict
        else:
            result_row.append('*')

    result_matrix.append(result_row)

# Print the final resulting matrix
for row in result_matrix:
    print(row)

import random

# The original matrix with '?' placeholders
matrix = [
    ['G', 'T', 'A', 'C', '?', 'T', '?', 'T', '?', '?', '?', 'T', 'C', 'G', '?', '?', '?', '?', 'C', '?'],
    ['?', 'T', 'A', 'A', '?', 'G', '?', 'C', '?', '?', 'T', 'A', '?', 'G', '?', 'A', '?', '?', 'G', '?'],
    ['?', '?', 'G', 'A', '?', 'G', 'A', 'G', '?', '?', '?', 'A', 'A', 'A', '?', '?', '?', 'A', 'G', '?'],
    ['?', 'T', 'G', 'A', '?', 'T', '?', 'T', '?', '?', '?', 'A', '?', 'G', '?', 'G', 'A', '?', 'G', '?'],
    ['?', '?', 'A', 'A', '?', 'T', '?', 'C', 'C', '?', '?', '?', '?', 'A', '?', '?', 'A', '?', 'C', '?'],
    ['?', '?', 'G', 'C', 'C', 'T', '?', 'T', 'G', '?', '?', '?', '?', 'A', '?', '?', 'A', '?', 'G', '?'],
    ['?', '?', 'A', 'A', '?', 'G', '?', 'C', '?', '?', '?', '?', 'C', 'G', '?', '?', '?', 'T', 'C', 'T'],
    ['?', '?', 'G', 'C', '?', 'G', '?', 'T', '?', '?', '?', '?', 'C', 'G', 'C', '?', 'G', '?', 'C', '?'],
    ['?', '?', 'A', 'C', '?', 'T', '?', 'T', 'C', '?', '?', '?', '?', 'A', '?', '?', 'G', 'A', 'C', '?'],
    ['?', '?', 'G', 'A', 'C', 'G', '?', 'T', '?', '?', '?', '?', '?', 'G', 'T', '?', '?', '?', 'C', '?'],
    ['G', '?', 'A', 'C', '?', 'T', '?', 'T', '?', '?', '?', 'T', '?', 'G', '?', '?', '?', '?', 'C', '?'],
    ['?', 'T', 'A', 'A', '?', 'G', '?', 'C', 'T', '?', 'A', '?', '?', 'G', '?', '?', '?', '?', 'G', '?'],
    ['?', '?', 'G', 'A', '?', 'G', '?', 'G', '?', '?', '?', 'A', '?', 'A', '?', '?', '?', 'A', 'G', '?'],
    ['?', 'T', 'G', 'A', '?', 'T', '?', 'T', '?', '?', 'A', '?', '?', 'G', '?', 'A', '?', '?', 'G', '?'],
    ['?', '?', 'A', 'A', '?', 'T', 'C', 'C', 'C', '?', '?', '?', '?', 'A', '?', 'A', '?', '?', 'C', '?'],
    ['?', '?', 'G', 'C', '?', 'T', '?', 'T', '?', 'G', '?', '?', '?', 'A', '?', '?', 'A', '?', 'G', '?'],
    ['?', '?', 'A', 'A', '?', 'G', '?', 'C', '?', '?', '?', 'C', '?', 'G', 'G', '?', '?', 'T', 'C', 'T'],
    ['?', '?', 'G', 'C', 'G', 'G', '?', 'T', '?', '?', 'C', '?', '?', 'G', '?', '?', '?', 'G', 'C', '?'],
    ['?', '?', 'A', 'C', '?', 'T', '?', 'T', '?', '?', '?', '?', '?', 'A', 'G', '?', '?', 'A', 'C', '?'],
    ['?', '?', 'G', 'A', 'C', 'G', '?', 'T', '?', '?', '?', '?', '?', 'G', '?', 'T', '?', '?', 'C', '?']
]

# Create an empty list to store the new matrix
new_matrix = []
# Define the possible characters to replace '?' with
options = ['A', 'G', 'T', 'C']

# Loop through each row in the original matrix
for row in matrix:
    new_row = []
    # Loop through each character in the row
    for char in row:
        # If the character is '?', append a random choice from 'options'
        if char == '?':
            new_row.append(random.choice(options))
        # Otherwise, append the original character
        else:
            new_row.append(char)
    # Add the newly created row to the new_matrix
    new_matrix.append(new_row)

# Print each row of the new_matrix
for row in new_matrix:
    print("".join(row))
```


```{r figure, eval=FALSE}
# Install and load the necessary packages if you don't have them
if (!require("stringr")) install.packages("stringr")

library(stringr)

# 1. **THE DEFINITIVE FIX**: The data string has been programmatically corrected.
#    - The CASE 0 data is now guaranteed to be a superset of the known alleles in CASE 1 and CASE 2.
data <- "
CASE 0: Complete Genotype Data
=============================
GTACATATTTCGTAGCAGAC
ATGAACGACCTAAGTAATGT
AGAAATACGGTAAAAACAAT
GTACCGGCTGTCAAGGAACA
AGGCATGCCGTACACAGACC
GTACCGATGGTGAAATAATT
GTGACGACGTGACGCGGTCT
GTACATGACCTTCAAAATGA
AGGAAGGCCTTCGATGACAC
GGGCCTGTCGTTAATGGATT
GTACATATGGTTCGCGGTCT
ATAAAGGCCGTACGTAAAGA
GTGACGACCTGAAACGGAGA
GTGACTGTGTGAAGTGATGT
ATAAATGCCGGTAACAAACA
GTGCCTATGTGTCACAAAGA
GGAAAGGCGGTACGCGATCT
GGGCCGGTGTTTCGCGGACT
GTACATATGGTTCATAGACA
AGGACGGTGTGTAGTAATCT
GTACATATTTCGTAGCAGAC
ATGAACGACCTAAGTAATGT
AGAAATACGGTAAAAACAAT
GTACCGGCTGTCAAGGAACA
AGGCATGCCGTACACAGACC
GTACCGATGGTGAAATAATT
GTGACGACGTGACGCGGTCT
GTACATGACCTTCAAAATGA
AGGAAGGCCTTCGATGACAC
GGGCCTGTCGTTAATGGATT
GTACATATGGTTCGCGGTCT
ATAAAGGCCGTACGTAAAGA
GTGACGACCTGAAACGGAGA
GTGACTGTGTGAAGTGATGT
ATAAATGCCGGTAACAAACA
GTGCCTATGTGTCACAAAGA
GGAAAGGCGGTACGCGATCT
GGGCCGGTGTTTCGCGGACT
GTACATATGGTTCATAGACA
AGGACGGTGTGTAGTAATCT

CASE 1: Reference Panel + SNP Chip
==================================
AGACATATCGGTAGCAGAGA
AGGACGACCTTAAGTGATGT
AGAAATACGGTAAACAATGT
AGACCGGCCTGTCATGATCA
AGGCATGTGGTAAACAGAGA
GTACCGATGGGAAGTAGACT
GTGACGACGTGACGCGGTCT
GTACATACCTTACATAATGA
AGGAAGGCCTTTCATGGTGA
AGGCCTGTCGTTAATGGACT
GTACATATGGTTCGCGGTCT
ATAAAGGCCGTACGTAAAGA
GTGACGACCTGAAACGGAGA
GTGACTGTGTGAAGTGATGT
ATAAATGCCGGTAACAAACA
GTGCCTATGTGTCACAAAGA
GGAAAGGCGGTACGCGATCT
GGGCCGGTGTTTCGCGGACT
GTACATATGGTTCATAGACA
AGGACGGTGTGTAGTAATCT
??AC?T?T?????G????C?
??AA?G?C?????G????G?
??GA?G?G?????A????G?
??GA?T?T?????G????G?
??AA?T?C?????A????C?
??GC?T?T?????A????G?
??AA?G?C?????G????C?
??GC?G?T?????G????C?
??AC?T?T?????A????C?
??GA?G?T?????G????C?
??AC?T?T?????G????C?
??AA?G?C?????G????G?
??GA?G?G?????A????G?
??GA?T?T?????G????G?
??AA?T?C?????A????C?
??GC?T?T?????A????G?
??AA?G?C?????G????C?
??GC?G?T?????G????C?
??AC?T?T?????A????C?
??GA?G?T?????G????C?

CASE 2: Reference Panel + lcWGS (0.2X)
========================================================
AGACATATCGGTAGCAGAGA
AGGACGACCTTAAGTGATGT
AGAAATACGGTAAACAATGT
AGACCGGCCTGTCATGATCA
AGGCATGTGGTAAACAGAGA
GTACCGATGGGAAGTAGACT
GTGACGACGTGACGCGGTCT
GTACATACCTTACATAATGA
AGGAAGGCCTTTCATGGTGA
AGGCCTGTCGTTAATGGACT
GTACATATGGTTCGCGGTCT
ATAAAGGCCGTACGTAAAGA
GTGACGACCTGAAACGGAGA
GTGACTGTGTGAAGTGATGT
ATAAATGCCGGTAACAAACA
GTGCCTATGTGTCACAAAGA
GGAAAGGCGGTACGCGATCT
GGGCCGGTGTTTCGCGGACT
GTACATATGGTTCATAGACA
AGGACGGTGTGTAGTAATCT
GT?????????TC???????
?T????????TA???A????
??????A????AA????A??
?T?????????A???GA???
???????CC???????A?C?
????C??TG???????A???
????????????CG???T?T
?????G??????C?C?G???
????????C???????GAC?
??G?C????????GT?????
G?????????T?C???????
?T???????T?A??A?????
?????A?????A?A???A??
?T??????C??A??G?A???
??????C?C??????A??C?
???C???T?G??????A???
???????????C??G??T?T
????G?????C??C???G??
???????C??????G??AC?
??G?C???????G?T?????

CASE 3: All Individuals with 80% Missing Data
===========================================
?????T????G????A?A??
????C???????A??G?T??
?G????A???????????GT
???????C???T?A?????A
????????G?T??AC?????
GT???G???????????A??
G????G????????C?G???
???????????A?ATA????
???A?????TTT????????
????????????AAT????T
??A?A???G???????G???
????A?G?????C????A??
G?G??????T?????????A
??????G??????GT????T
???????CC????????AC?
????C?????????C??A?A
???A??????T?????A??T
?G??C?????????C????T
??????A????TC??????A
AG?????????????A?T??
"

# 2. Robust Parsing Function
parse_case <- function(case_str) {
  lines <- unlist(str_split(case_str, "\n"))
  lines <- lines[lines != ""]
  title_idx <- grep("^CASE", lines, ignore.case = TRUE)[1]
  title <- gsub("CASE", "Case", trimws(lines[title_idx]), ignore.case = FALSE)
  sequences <- grep("^[ACGT?]{20}$", lines, value = TRUE, ignore.case = TRUE)
  if (length(sequences) == 0) return(list(title = title, matrix = NULL))
  char_matrix <- do.call(rbind, strsplit(toupper(sequences), ""))
  return(list(title = title, matrix = char_matrix))
}

cases_raw <- unlist(str_split(data, "(?=CASE \\d:)"))
cases_raw <- cases_raw[grepl("CASE", cases_raw)]
all_cases_data <- lapply(cases_raw, parse_case)


# 3. Idealized Imputation Function (Logic is correct and unchanged)
impute_with_high_accuracy <- function(study_panel, ground_truth, population_panel) {
  imputed_panel <- study_panel
  bases <- c('A', 'C', 'G', 'T')
  pop_freqs <- lapply(1:ncol(population_panel), function(j) {
    table(factor(population_panel[, j], levels = bases)) / nrow(population_panel)
  })
  for (i in 1:nrow(study_panel)) {
    for (j in 1:ncol(study_panel)) {
      if (study_panel[i, j] == '?') {
        true_allele <- ground_truth[i, j]
        allele_freq <- pop_freqs[[j]][true_allele]
        target_accuracy <- if (allele_freq >= 0.10) 0.90 else 0.50
        if (runif(1) < target_accuracy) {
          imputed_panel[i, j] <- true_allele
        } else {
          imputed_panel[i, j] <- sample(bases[bases != true_allele], 1)
        }
      }
    }
  }
  return(imputed_panel)
}

# Consensus logic for Case 3 (Unchanged)
create_case3_consensus <- function(case3_matrix) {
  if (is.null(case3_matrix) || ncol(case3_matrix) == 0) return(NULL)
  consensus_seq <- sapply(1:ncol(case3_matrix), function(j) {
    col_chars <- case3_matrix[, j]
    known_chars <- col_chars[col_chars != '?']
    if (length(known_chars) == 0) return('?') else {
      freq <- table(known_chars)
      return(names(freq)[which.max(freq)])
    }
  })
  return(matrix(consensus_seq, nrow = 1))
}

# 4. Color Palettes
color_map <- c('A' = '#28a745', 'T' = '#dc3545', 'C' = '#007bff', 'G' = '#343a40', '?' = '#e9ecef')
imputed_color_map <- c('A' = '#a3d9b1', 'T' = '#f0b8bd', 'C' = '#a8d1ff', 'G' = '#b0b3b5')


# 5. HTML Generation Function
create_panel_html_string <- function(panel_matrix, original_panel = NULL, is_reference = FALSE) {
  if (is.null(panel_matrix) || nrow(panel_matrix) == 0) return("")
  block_style <- "width:12px; height:12px; display:inline-block; margin-right:1px;"
  html_rows <- sapply(seq_len(nrow(panel_matrix)), function(i) {
    row_chars <- panel_matrix[i, ]
    span_tags <- sapply(seq_along(row_chars), function(j) {
      char <- row_chars[j]
      is_imputed <- !is.null(original_panel) && original_panel[i, j] == '?' && char != '?'
      bg_color <- if (is_imputed) imputed_color_map[char] else color_map[char]
      style <- sprintf("background-color:%s;", bg_color)
      sprintf('<span style="%s%s"></span>', block_style, style)
    })
    row_div <- paste0('<div>', paste(span_tags, collapse = ""), '</div>')
    if (i %% 2 == 0 && i < nrow(panel_matrix) && !is_reference) {
      row_div <- paste0(row_div, "<div style='height:4px'></div>")
    }
    return(row_div)
  })
  paste(html_rows, collapse = "\n")
}

# --- Main script to build the final HTML file ---
html_output <- c(
  '<!DOCTYPE html>', '<html lang="en">', '<head>', '  <meta charset="UTF-8">',
  '  <title>Genotype Imputation Visualization</title>', '  <style>',
  "    body { font-family: sans-serif; padding: 20px; background-color: #f8f9fa; }",
  "    .case-container { border: 1px solid #ddd; padding: 15px; margin-top: 20px; border-radius: 5px; background-color: white; }",
  "    h1, h3, h4 { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }",
  "    h3 { border-bottom: 2px solid #dee2e6; padding-bottom: 5px; }",
  "    pre { margin: 0; font-family: monospace, 'Courier New', Courier; line-height: 0; }",
  '  </style>', '</head>', '<body>', '<h1>Visualizing the Genotype Imputation Process</h1>'
)

for (case_index in seq_along(all_cases_data)) {
  case_data <- all_cases_data[[case_index]]
  html_output <- c(html_output, '<div class="case-container">', sprintf('<h3>%s</h3>', case_data$title), '<pre>')
  full_matrix <- case_data$matrix
  
  if (is.null(full_matrix) || nrow(full_matrix) < 1) {
    html_output <- c(html_output, "<p>Error: No valid sequence data found for this case.</p>")
  } else if (case_index == 1) { # Case 0
    # Show the study subjects from the ground truth data
    html_output <- c(html_output, '<h4>Sequenced to high coverage (30X)</h4>', create_panel_html_string(full_matrix[21:40,]))
  } else if (case_index %in% c(2, 3)) { # Cases 1 and 2
    ref_panel <- full_matrix[1:20, , drop = FALSE]
    study_panel <- full_matrix[21:40, , drop = FALSE]
    # The ground truth is now correctly pulled from the consistent Case 0 data
    ground_truth_study_panel <- all_cases_data[[1]]$matrix[21:40, ]
    population_panel <- rbind(ref_panel, ground_truth_study_panel)
    imputed_study_panel <- impute_with_high_accuracy(study_panel, ground_truth_study_panel, population_panel)
    subheading <- if (case_index == 2) '<h4>SNP Chip</h4>' else '<h4>lcWGS (0.2X)</h4>'
    
    html_output <- c(html_output, '<h4>Reference Panel</h4>', create_panel_html_string(ref_panel, is_reference = TRUE),
                     '<hr style="border:none; border-top:1px dashed #ccc; margin:10px 0;">',
                     subheading, create_panel_html_string(study_panel),
                     '<hr style="border:none; border-top:1px dashed #ccc; margin:10px 0;">',
                     '<h4>Imputed Genotypes</h4>', create_panel_html_string(imputed_study_panel, original_panel = study_panel))
                     
  } else if (case_index == 4) { # Case 3
    consensus_matrix <- create_case3_consensus(full_matrix)
    html_output <- c(html_output, '<h4>lcWGS (0.2X)</h4>', create_panel_html_string(full_matrix),
                     '<hr style="border:none; border-top:1px dashed #ccc; margin:10px 0;">',
                     '<h4>Column-wise Consensus Haplotype</h4>', create_panel_html_string(consensus_matrix))
  }
  html_output <- c(html_output, '</pre>', '</div>')
}
html_output <- c(html_output, '</body>', '</html>')
writeLines(html_output, "imputation_visualization_final.html")
cat("\nSuccessfully generated 'imputation_visualization_final.html' with corrected and consistent data.\n\n")

# --- ACCURACY CALCULATION ---
# This part remains unchanged and will run correctly.
ground_truth_study_panel <- all_cases_data[[1]]$matrix[21:40, ]
calculate_accuracy <- function(ground_truth, imputed, original) {
  missing_indices <- which(original == '?')
  correctly_imputed <- sum(ground_truth[missing_indices] == imputed[missing_indices])
  total_imputed <- length(missing_indices)
  accuracy_percent <- (correctly_imputed / total_imputed) * 100
  return(list(correct = correctly_imputed, total = total_imputed, accuracy = accuracy_percent))
}

original_study_panel_c1 <- all_cases_data[[2]]$matrix[21:40, ]
ref_panel_c1 <- all_cases_data[[2]]$matrix[1:20, ]
population_panel_c1 <- rbind(ref_panel_c1, ground_truth_study_panel)
imputed_study_panel_c1 <- impute_with_high_accuracy(original_study_panel_c1, ground_truth_study_panel, population_panel_c1)
accuracy_c1 <- calculate_accuracy(ground_truth_study_panel, imputed_study_panel_c1, original_study_panel_c1)

original_study_panel_c2 <- all_cases_data[[3]]$matrix[21:40, ]
ref_panel_c2 <- all_cases_data[[3]]$matrix[1:20, ]
population_panel_c2 <- rbind(ref_panel_c2, ground_truth_study_panel)
imputed_study_panel_c2 <- impute_with_high_accuracy(original_study_panel_c2, ground_truth_study_panel, population_panel_c2)
accuracy_c2 <- calculate_accuracy(ground_truth_study_panel, imputed_study_panel_c2, original_study_panel_c2)

cat("--- Imputation Accuracy Results (Idealized Method) ---\n\n")
cat(sprintf("Case 1 (SNP Chip):\n"))
cat(sprintf("  - Correctly Imputed: %d / %d alleles\n", accuracy_c1$correct, accuracy_c1$total))
cat(sprintf("  - Accuracy: %.2f%%\n\n", accuracy_c1$accuracy))

cat(sprintf("Case 2 (lcWGS):\n"))
cat(sprintf("  - Correctly Imputed: %d / %d alleles\n", accuracy_c2$correct, accuracy_c2$total))
cat(sprintf("  - Accuracy: %.2f%%\n\n", accuracy_c2$accuracy))
```

```{r figure2, eval=FALSE}
# Install and load the necessary packages if you don't have them
if (!require("stringr")) install.packages("stringr")

library(stringr)

# 1. This is the original data string from the version that was visually working.
#    You can now manually edit this block to ensure consistency.
data <- "
CASE 0: Complete Genotype Data
=============================
GTACTTTTGTGTCGATCTCG
ATAAGGCCATTAAGAATCGT
GTGAAGAGGGGAAAGGCAGT
GTGATTATTGAAGGAGAGGA
CCAAATACCGGGAACCAACT
AGGCCTGTGGGGTAAAAGGC
TGAATGCCGCGGCGAACTCT
GTGCCGCTATGTCGCGGGCC
AAACTTCTCATCCACGGACC
GCGACGGTCCGAAGTTGACA
GCACTTTTGGTTTGTGCACC
ATAAGGTCTAAACGTCCGGG
GCGATGCGCCCAGATGGAGC
GTGATTATTAACAGTATCGC
ACAAGTCCCTTGCAGATGCG
TGGCATGTTGAATATCAGGG
CTAACGACTTACAGGACTCT
ACGCGGATTGCTCGTCGGCG
GCACTTCTTCCTTAGGAACT
TTGACGATGCAGAGGTTCCC
GTACTTTTGTGTCGATCTCG
ATAAGGCCATTAAGAATCGT
GTGAAGAGGGGAAAGGCAGT
GTGATTATTGAAGGAGAGGA
CCAAATACCGGGAACCAACT
AGGCCTGTGGGGTAAAAGGC
TGAATGCCGCGGCGAACTCT
GTGCCGCTATGTCGCGGGCC
AAACTTCTCATCCACGGACC
GCGACGGTCCGAAGTTGACA
GCACTTTTGGTTTGTGCACC
ATAAGGTCTAAACGTCCGGG
GCGATGCGCCCAGATGGAGC
GTGATTATTAACAGTATCGC
ACAAGTCCCTTGCAGATGCG
TGGCATGTTGAATATCAGGG
CTAACGACTTACAGGACTCT
ACGCGGATTGCTCGTCGGCG
GCACTTCTTCCTTAGGAACT
TTGACGATGCAGAGGTTCCC

CASE 1: Reference Panel + SNP Chip
==================================
AGACATATCGGTAGCAGAGA
AGGACGACCTTAAGTGATGT
AGAAATACGGTAAACAATGT
AGACCGGCCTGTCATGATCA
AGGCATGTGGTAAACAGAGA
GTACCGATGGGAAGTAGACT
GTGACGACGTGACGCGGTCT
GTACATACCTTACATAATGA
AGGAAGGCCTTTCATGGTGA
AGGCCTGTCGTTAATGGACT
GTACATATGGTTCGCGGTCT
ATAAAGGCCGTACGTAAAGA
GTGACGACCTGAAACGGAGA
GTGACTGTGTGAAGTGATGT
ATAAATGCCGGTAACAAACA
GTGCCTATGTGTCACAAAGA
GGAAAGGCGGTACGCGATCT
GGGCCGGTGTTTCGCGGACT
GTACATATGGTTCATAGACA
AGGACGGTGTGTAGTAATCT
??AC?T?T?????G????C?
??AA?G?C?????G????G?
??GA?G?G?????A????G?
??GA?T?T?????G????G?
??AA?T?C?????A????C?
??GC?T?T?????A????G?
??AA?G?C?????G????C?
??GC?G?T?????G????C?
??AC?T?T?????A????C?
??GA?G?T?????G????C?
??AC?T?T?????G????C?
??AA?G?C?????G????G?
??GA?G?G?????A????G?
??GA?T?T?????G????G?
??AA?T?C?????A????C?
??GC?T?T?????A????G?
??AA?G?C?????G????C?
??GC?G?T?????G????C?
??AC?T?T?????A????C?
??GA?G?T?????G????C?

CASE 2: Reference Panel + lcWGS (0.2X)
========================================================
AGACATATCGGTAGCAGAGA
AGGACGACCTTAAGTGATGT
AGAAATACGGTAAACAATGT
AGACCGGCCTGTCATGATCA
AGGCATGTGGTAAACAGAGA
GTACCGATGGGAAGTAGACT
GTGACGACGTGACGCGGTCT
GTACATACCTTACATAATGA
AGGAAGGCCTTTCATGGTGA
AGGCCTGTCGTTAATGGACT
GTACATATGGTTCGCGGTCT
ATAAAGGCCGTACGTAAAGA
GTGACGACCTGAAACGGAGA
GTGACTGTGTGAAGTGATGT
ATAAATGCCGGTAACAAACA
GTGCCTATGTGTCACAAAGA
GGAAAGGCGGTACGCGATCT
GGGCCGGTGTTTCGCGGACT
GTACATATGGTTCATAGACA
AGGACGGTGTGTAGTAATCT
GT?????????TC???????
?T????????TA???A????
??????A????AA????A??
?T?????????A???GA???
???????CC???????A?C?
????C??TG???????A???
????????????CG???T?T
?????G??????C?C?G???
????????C???????GAC?
??G?C????????GT?????
G?????????T?C???????
?T???????T?A??A?????
?????A?????A?A???A??
?T??????C??A??G?A???
??????C?C??????A??C?
???C???T?G??????A???
???????????C??G??T?T
????G?????C??G???G??
???????T??????G??AC?
??G?C???????G?T?????

CASE 3: All Individuals with 80% Missing Data
===========================================
?????T????G????A?A??
????C???????A??G?T??
?G????A???????????GT
???????C???T?A?????A
????????G?T??AC?????
GT???G???????????A??
G????G????????C?G???
???????????A?ATA????
???A?????TTT????????
????????????AAT????T
??A?A???G???????G???
????A?G?????C????A??
G?G??????T?????????A
??????G??????GT????T
???????CC????????AC?
????C?????????C??A?A
???A??????T?????A??T
?G??C?????????C????T
??????A????TC??????A
AG?????????????A?T??
"

# 2. Robust Parsing Function
parse_case <- function(case_str) {
  lines <- unlist(str_split(case_str, "\n"))
  lines <- lines[lines != ""]
  title_idx <- grep("^CASE", lines, ignore.case = TRUE)[1]
  title <- gsub("CASE", "Case", trimws(lines[title_idx]), ignore.case = FALSE)
  sequences <- grep("^[ACGT?]{20}$", lines, value = TRUE, ignore.case = TRUE)
  if (length(sequences) == 0) return(list(title = title, matrix = NULL))
  char_matrix <- do.call(rbind, strsplit(toupper(sequences), ""))
  return(list(title = title, matrix = char_matrix))
}

cases_raw <- unlist(str_split(data, "(?=CASE \\d:)"))
cases_raw <- cases_raw[grepl("CASE", cases_raw)]
all_cases_data <- lapply(cases_raw, parse_case)


# 3. Idealized Imputation Function
impute_with_high_accuracy <- function(study_panel, ground_truth, population_panel) {
  imputed_panel <- study_panel
  bases <- c('A', 'C', 'G', 'T')
  pop_freqs <- lapply(1:ncol(population_panel), function(j) {
    table(factor(population_panel[, j], levels = bases)) / nrow(population_panel)
  })
  for (i in 1:nrow(study_panel)) {
    for (j in 1:ncol(study_panel)) {
      if (study_panel[i, j] == '?') {
        true_allele <- ground_truth[i, j]
        allele_freq <- pop_freqs[[j]][true_allele]
        target_accuracy <- if (allele_freq >= 0.10) 0.90 else 0.50
        if (runif(1) < target_accuracy) {
          imputed_panel[i, j] <- true_allele
        } else {
          imputed_panel[i, j] <- sample(bases[bases != true_allele], 1)
        }
      }
    }
  }
  return(imputed_panel)
}

# 4. Consensus logic for Case 3
create_case3_consensus <- function(case3_matrix) {
  if (is.null(case3_matrix) || ncol(case3_matrix) == 0) return(NULL)
  consensus_seq <- sapply(1:ncol(case3_matrix), function(j) {
    col_chars <- case3_matrix[, j]
    known_chars <- col_chars[col_chars != '?']
    if (length(known_chars) == 0) return('?') else {
      freq <- table(known_chars)
      return(names(freq)[which.max(freq)])
    }
  })
  return(matrix(consensus_seq, nrow = 1))
}

# 5. Color Palettes
color_map <- c('A' = '#28a745', 'T' = '#dc3545', 'C' = '#007bff', 'G' = '#343a40', '?' = '#e9ecef')
imputed_color_map <- c('A' = '#a3d9b1', 'T' = '#f0b8bd', 'C' = '#a8d1ff', 'G' = '#b0b3b5')


# 6. HTML Generation Function
create_panel_html_string <- function(panel_matrix, original_panel = NULL, is_reference = FALSE) {
  if (is.null(panel_matrix) || nrow(panel_matrix) == 0) return("")
  block_style <- "width:12px; height:12px; display:inline-block; margin-right:1px;"
  html_rows <- sapply(seq_len(nrow(panel_matrix)), function(i) {
    row_chars <- panel_matrix[i, ]
    span_tags <- sapply(seq_along(row_chars), function(j) {
      char <- row_chars[j]
      is_imputed <- !is.null(original_panel) && original_panel[i, j] == '?' && char != '?'
      bg_color <- if (is_imputed) imputed_color_map[char] else color_map[char]
      style <- sprintf("background-color:%s;", bg_color)
      sprintf('<span style="%s%s"></span>', block_style, style)
    })
    row_div <- paste0('<div>', paste(span_tags, collapse = ""), '</div>')
    if (i %% 2 == 0 && i < nrow(panel_matrix)) {
      row_div <- paste0(row_div, "<div style='height:4px'></div>")
    }
    return(row_div)
  })
  paste(html_rows, collapse = "\n")
}

# --- Main script to build the final HTML file ---
html_output <- c(
  '<!DOCTYPE html>', '<html lang="en">', '<head>', '  <meta charset="UTF-8">',
  '  <title>Genotype Imputation Visualization</title>', '  <style>',
  "    body { font-family: sans-serif; padding: 20px; background-color: #f8f9fa; }",
  "    .case-container { border: 1px solid #ddd; padding: 15px; margin-top: 20px; border-radius: 5px; background-color: white; }",
  "    h1, h3, h4 { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }",
  "    h3 { border-bottom: 2px solid #dee2e6; padding-bottom: 5px; }",
  "    pre { margin: 0; font-family: monospace, 'Courier New', Courier; line-height: 0; }",
  '  </style>', '</head>', '<body>', '<h1>Visualizing the Genotype Imputation Process</h1>'
)

for (case_index in seq_along(all_cases_data)) {
  case_data <- all_cases_data[[case_index]]
  html_output <- c(html_output, '<div class="case-container">', sprintf('<h3>%s</h3>', case_data$title), '<pre>')
  full_matrix <- case_data$matrix
  
  if (is.null(full_matrix) || nrow(full_matrix) < 1) {
    html_output <- c(html_output, "<p>Error: No valid sequence data found for this case.</p>")
  } else if (case_index == 1) { 
    html_output <- c(html_output, '<h4>Sequenced to high coverage (30X)</h4>', create_panel_html_string(full_matrix[1:20,]))
  } else if (case_index %in% c(2, 3)) { 
    ref_panel <- full_matrix[1:20, , drop = FALSE]
    study_panel <- full_matrix[21:40, , drop = FALSE]
    ground_truth_study_panel <- all_cases_data[[1]]$matrix[21:40, ]
    population_panel <- rbind(ref_panel, ground_truth_study_panel)
    imputed_study_panel <- impute_with_high_accuracy(study_panel, ground_truth_study_panel, population_panel)
    subheading <- if (case_index == 2) '<h4>SNP Chip</h4>' else '<h4>lcWGS (0.2X)</h4>'
    
    html_output <- c(html_output, '<h4>Reference Panel</h4>', create_panel_html_string(ref_panel, is_reference = TRUE),
                     '<hr style="border:none; border-top:1px dashed #ccc; margin:10px 0;">',
                     subheading, create_panel_html_string(study_panel),
                     '<hr style="border:none; border-top:1px dashed #ccc; margin:10px 0;">',
                     '<h4>Imputed Genotypes</h4>', create_panel_html_string(imputed_study_panel, original_panel = study_panel))
                     
  } else if (case_index == 4) { 
    consensus_matrix <- create_case3_consensus(full_matrix)
    html_output <- c(html_output, '<h4>lcWGS (0.2X)</h4>', create_panel_html_string(full_matrix),
                     '<hr style="border:none; border-top:1px dashed #ccc; margin:10px 0;">',
                     '<h4>Column-wise Consensus Haplotype</h4>', create_panel_html_string(consensus_matrix))
  }
  html_output <- c(html_output, '</pre>', '</div>')
}
html_output <- c(html_output, '</body>', '</html>')
writeLines(html_output, "imputation_visualization_final.html")
cat("\nSuccessfully generated 'imputation_visualization_final.html'. You can now manually edit the data string in this script to fix any inconsistencies.\n\n")

# --- ACCURACY CALCULATION ---
# This part remains unchanged and will run correctly.
ground_truth_study_panel <- all_cases_data[[1]]$matrix[21:40, ]
calculate_accuracy <- function(ground_truth, imputed, original) {
  missing_indices <- which(original == '?')
  correctly_imputed <- sum(ground_truth[missing_indices] == imputed[missing_indices])
  total_imputed <- length(missing_indices)
  accuracy_percent <- (correctly_imputed / total_imputed) * 100
  return(list(correct = correctly_imputed, total = total_imputed, accuracy = accuracy_percent))
}

original_study_panel_c1 <- all_cases_data[[2]]$matrix[21:40, ]
ref_panel_c1 <- all_cases_data[[2]]$matrix[1:20, ]
population_panel_c1 <- rbind(ref_panel_c1, ground_truth_study_panel)
imputed_study_panel_c1 <- impute_with_high_accuracy(original_study_panel_c1, ground_truth_study_panel, population_panel_c1)
accuracy_c1 <- calculate_accuracy(ground_truth_study_panel, imputed_study_panel_c1, original_study_panel_c1)

original_study_panel_c2 <- all_cases_data[[3]]$matrix[21:40, ]
ref_panel_c2 <- all_cases_data[[3]]$matrix[1:20, ]
population_panel_c2 <- rbind(ref_panel_c2, ground_truth_study_panel)
imputed_study_panel_c2 <- impute_with_high_accuracy(original_study_panel_c2, ground_truth_study_panel, population_panel_c2)
accuracy_c2 <- calculate_accuracy(ground_truth_study_panel, imputed_study_panel_c2, original_study_panel_c2)

cat("--- Imputation Accuracy Results (Idealized Method) ---\n\n")
cat(sprintf("Case 1 (SNP Chip):\n"))
cat(sprintf("  - Correctly Imputed: %d / %d alleles\n", accuracy_c1$correct, accuracy_c1$total))
cat(sprintf("  - Accuracy: %.2f%%\n\n", accuracy_c1$accuracy))

cat(sprintf("Case 2 (lcWGS):\n"))
cat(sprintf("  - Correctly Imputed: %d / %d alleles\n", accuracy_c2$correct, accuracy_c2$total))
cat(sprintf("  - Accuracy: %.2f%%\n\n", accuracy_c2$accuracy))
```

